## API Report File for "@contember/utilities"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { CamelCase } from 'type-fest';
import { DelimiterCase } from 'type-fest';
import { KebabCase } from 'type-fest';
import { LiteralToPrimitiveDeep } from 'type-fest';
import { MergeExclusive } from 'type-fest';
import { Opaque } from 'type-fest';
import { PascalCase } from 'type-fest';
import { Replace } from 'type-fest';
import { Simplify } from 'type-fest';
import { UnionToIntersection } from 'type-fest';
import { UnwrapOpaque } from 'type-fest';

// @public (undocumented)
export type AnyArray<Type = any> = Array<Type> | ReadonlyArray<Type>;

// @public (undocumented)
export type AnyRecord<T = any> = Record<KeyofBase, T>;

// @public (undocumented)
export type AsProp<C extends React.ElementType> = {
    as?: C;
};

// @public (undocumented)
export function assert<In, Out extends In>(that: string | undefined, value: In, predicate: Predicate<In, Out>): asserts value is Out;

// @public (undocumented)
export class AssertionError extends Error {
    constructor(value: unknown, that?: string);
}

// @public (undocumented)
export function assertNever(_: never): never;

export { CamelCase }

// @public (undocumented)
export function capitalize(str: string): string;

// @public (undocumented)
export type ClassNameStateMap = {
    [key: string]: string | number | boolean | null | undefined;
};

// @internal
export const COLOR_SCHEME_CLASS_NAME_REG_EXP: RegExp;

// @public (undocumented)
export type ColorSchemeClassName<T extends KebabCase<string> = KebabCase<string>> = `scheme-${T}`;

// @public
export function colorSchemeClassName<S extends KebabCase<string> = KebabCase<string>>(scheme: S): ColorSchemeClassName<S>;

// @public (undocumented)
export function colorSchemeClassName<S extends KebabCase<string> = KebabCase<string>>(scheme: null | undefined): undefined;

// @public (undocumented)
export function colorSchemeClassName<S extends KebabCase<string> = KebabCase<string>>(scheme: S | null | undefined): ColorSchemeClassName<S> | undefined;

// @public (undocumented)
export interface ComponentClassNameProps {
    // (undocumented)
    className?: NestedClassName;
    // (undocumented)
    componentClassName?: string | string[];
}

// @public
export function contentThemeClassName<ContentTheme extends KebabCase<string> = KebabCase<string>>(theme: ContentTheme | null | undefined): `theme-${ContentTheme}-content` | undefined;

// @public
export function controlsThemeClassName<ControlsTheme extends KebabCase<string> = KebabCase<string>>(theme: ControlsTheme | null | undefined): `theme-${ControlsTheme}-controls` | undefined;

// @public (undocumented)
export function dataAttribute(value: unknown): string | true | undefined;

// @public (undocumented)
export const dateToStringWithoutTimezone: (date: Date, { includeTime }?: {
    includeTime?: boolean | undefined;
}) => string;

// @public (undocumented)
export function deduplicateClassName(classNameArray: string[]): string[];

// @public (undocumented)
export type DeepPartial<T> = T extends Function ? T : T extends Array<infer InferredArrayMember> ? Array<DeepPartial<InferredArrayMember>> : T extends object ? {
    [Key in keyof T]?: DeepPartial<T[Key]>;
} : T | undefined;

export { DelimiterCase }

// @internal
export function deprecate(removal: SemverString, condition: boolean, deprecated: string, replacement: string | null): void;

// @internal (undocumented)
export function extend<B, E>(base: B, extension: E): B | E | readonly (B & object & any[])[number][] | Readonly<{
    [k: string]: unknown;
}>;

// @public
export type ExtendableProps<ExtendedProps = {}, OverrideProps = {}> = OverrideProps & Omit<ExtendedProps, keyof OverrideProps>;

// @public (undocumented)
export function fallback<R>(current: R, condition: boolean, mapped: R): R;

// @public (undocumented)
export function filterThemedClassName(nestedClassName: NestedClassName, defaultColorSchemeContext: ColorSchemeClassName): string[];

// @public (undocumented)
export function flatClassNameList(className: NestedClassName): string[];

// @public
export function getElementDimensions(element: HTMLElement): Promise<DOMRectReadOnly>;

// @public
export function getElementDimensionsCallback(element: HTMLElement, callback: (dimensions: DOMRectReadOnly) => void): void;

// @public (undocumented)
export function getMatchingParentElement(element: HTMLElement | null, predicate: (element: HTMLElement | null) => boolean | Promise<boolean>): HTMLElement;

// @public (undocumented)
export function getSizeFromResizeObserverEntryFactory(box: ResizeObserverOptions['box']): (entry: ResizeObserverEntry) => {
    height: number;
    width: number;
};

// @public
export type InheritableElementProps<C extends React.ElementType, Props = {}> = ExtendableProps<PropsOf<C>, Props>;

// @public (undocumented)
export function isArrayOfMembersSatisfyingFactory<T>(predicate: (value: unknown) => value is T): (value: unknown) => value is Array<T>;

// @public (undocumented)
export function isBoolean(value: unknown): value is boolean;

// @internal
export function isColorSchemeClassName<T extends string>(value: string): value is ColorSchemeClassName<T>;

// @public (undocumented)
export function isDefined<T>(value: unknown): value is Exclude<T, undefined>;

// @public (undocumented)
export function isFalse(value: unknown): value is false;

// @public (undocumented)
export function isHTMLElement(value: unknown): value is HTMLElement;

// @public (undocumented)
export function isNonEmptyArray<T>(value: unknown): value is [T, ...T[]];

// @public (undocumented)
export function isNonEmptyString(value: unknown): value is string;

// @public (undocumented)
export const isNonEmptyTrimmedEndString: (value: unknown) => value is string;

// @public (undocumented)
export const isNonEmptyTrimmedStartString: (value: unknown) => value is string;

// @public (undocumented)
export const isNonEmptyTrimmedString: (value: unknown) => value is string;

// @public (undocumented)
export function isNonNegativeNumber(value: unknown): value is number;

// @public (undocumented)
export function isNotNull<T>(value: unknown): value is T;

// @public (undocumented)
export function isNotNullish<T>(value: T): value is Exclude<T, null | undefined>;

// @public (undocumented)
export function isNull(value: unknown): value is null;

// @public (undocumented)
export function isNumber(value: unknown): value is number;

// @public (undocumented)
export function isNumericString(value: string): value is string;

// @public (undocumented)
export function isObject(value: unknown): value is Object;

// @public (undocumented)
export function isOneOfFactory<U, T = any>(members: T extends Array<U> | ReadonlyArray<U> ? T : never): (value: unknown) => value is U;

// @public (undocumented)
export function isPlainObject<T extends Record<string, unknown>>(value: unknown): value is T;

// @public
export function isScrollable(element: HTMLElement | null): boolean;

// @public (undocumented)
export function isSingleWordString(value: unknown): value is string;

// @public (undocumented)
export function isSlugString(value: unknown): value is SlugString;

// @public (undocumented)
export function isString(value: unknown): value is string;

// @public (undocumented)
export function isTrue(value: unknown): value is true;

// @public (undocumented)
export function isUndefined(value: unknown): value is undefined;

export { KebabCase }

// @public (undocumented)
export type KeyofBase = keyof any;

// @public
export function listClassName(list: NestedClassName): string;

export { LiteralToPrimitiveDeep }

export { MergeExclusive }

// Warning: (ae-forgotten-export) The symbol "NarrowRaw" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Narrow<A extends any> = Try<A, [], NarrowRaw<A>>;

// @public
export type Narrowable = string | number | bigint | boolean;

// @public (undocumented)
export type NestedClassName = string | false | null | undefined | (string | false | null | undefined)[] | NestedClassName[];

// @public (undocumented)
export type NonNullableRequired<T> = {
    [P in keyof T]-?: NonNullable<T[P]>;
};

// @public
export type NonOptional<T> = {
    [P in keyof Required<T>]: Pick<T, P> extends Required<Pick<T, P>> ? T[P] : (T[P] | undefined);
};

// @public (undocumented)
export type ObjectKeyValue<T, K extends keyof T> = T extends {
    [P in K]: T[P];
} ? T[K] : never;

// @public (undocumented)
export function omit<T extends Object, K extends keyof T>(object: T, properties: ReadonlyArray<K>, strict?: boolean): Omit<T, K>;

export { Opaque }

// @public
export function parseTransformMatrix(transform?: string): {
    scaleX: number;
    skewY: number;
    skewX: number;
    scaleY: number;
    translateX: number;
    translateY: number;
} | undefined;

export { PascalCase }

// @public (undocumented)
export function pick<T extends Object, K extends keyof T>(object: T, properties: ReadonlyArray<K>): Pick<T, K>;

// @public
export type PolymorphicComponent<T extends React.ElementType, P = {}> = (<C extends React.ElementType = T>(props: PolymorphicComponentPropsWithRef<C, P>) => React.ReactElement | null) & {
    displayName?: string | undefined;
};

// @public
export type PolymorphicComponentProps<C extends React.ElementType, Props = {}> = InheritableElementProps<C, Props & AsProp<C>>;

// @public
export type PolymorphicComponentPropsWithRef<C extends React.ElementType, Props = {}> = PolymorphicComponentProps<C, Props> & {
    ref?: PolymorphicRef<C>;
};

// @public
export type PolymorphicRef<C extends React.ElementType> = React.ComponentPropsWithRef<C>['ref'];

// @public (undocumented)
export type Predicate<T, U extends T> = (value: T) => value is U;

// @public (undocumented)
export type Primitive = string | number | boolean | null | undefined;

// @public (undocumented)
export type PropsOf<C extends keyof JSX.IntrinsicElements | React.JSXElementConstructor<any>> = JSX.LibraryManagedAttributes<C, React.ComponentPropsWithoutRef<C>>;

// @public (undocumented)
export function px<V extends number>(value: V): `${V}px`;

// @public (undocumented)
export function px<V extends false>(value: V): '';

// @public (undocumented)
export function px<V extends null>(value: V): '';

// @public (undocumented)
export function px<V extends undefined>(value: V): '';

// @public (undocumented)
export function px<V extends number | false | null | undefined>(value?: V): string;

// @public
export function range(start: number, end: number, step?: number): number[];

export { Replace }

// @public (undocumented)
export type RequiredDeepPlainObject<T extends RequiredDeepPlainObject<Record<string, unknown>> = RequiredDeepPlainObject<Record<string, unknown>>, K extends keyof T & string = keyof T & string> = {
    [P in K]-?: T[P] extends Record<string, unknown> ? RequiredDeepPlainObject<T[P]> : T[P];
};

// @public (undocumented)
export function satisfiesOneOfFactory<T extends Array<Predicate<any, any>>>(...predicates: T): Predicate<unknown, UnionOfPredicateTypes<T>>;

// @public (undocumented)
export type SemverString = `${number}.${number}.${number}`;

// @public (undocumented)
export function setHasOneOf<T>(set: Set<T>, values: T[]): boolean;

// @public (undocumented)
export const shouldCancelStart: (event: {
    target?: unknown;
}) => boolean;

export { Simplify }

// @public (undocumented)
export type SlugString = Opaque<string, 'SlugString'>;

// Warning: (tsdoc-param-tag-with-invalid-name) The @param block should be followed by a valid parameter name: The identifier cannot non-word characters
// Warning: (tsdoc-param-tag-with-invalid-name) The @param block should be followed by a valid parameter name: The identifier cannot non-word characters
//
// @public
export function stateClassName(state?: ClassNameStateMap | null, { glue, removeFalsy }?: StateClassNameOptions): string[];

// @public (undocumented)
export interface StateClassNameOptions {
    // (undocumented)
    glue?: string;
    // (undocumented)
    removeFalsy?: boolean;
}

// @public (undocumented)
export function stateDataAttributes(state: Record<string, unknown>): {
    [k: string]: string | true | undefined;
};

// @public (undocumented)
export interface SvgSizeProps {
    // (undocumented)
    height: number;
    // (undocumented)
    viewBox: string;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export function svgSizeProps(width: number, height?: number, crop?: number): SvgSizeProps;

// @internal
export const THEME_CLASS_NAME_REG_EXP: RegExp;

// @public
export function themeClassName<Theme extends KebabCase<string> = KebabCase<string>>(theme: Theme | null | undefined): readonly [`theme-${Theme}-content` | undefined, `theme-${Theme}-controls` | undefined];

// @public (undocumented)
export type ThemeConfig = {
    content: string | undefined;
    controls: string | undefined;
};

// @public (undocumented)
export type ThemeContentClassName<T extends KebabCase<string> = KebabCase<string>> = `theme-${T}-content`;

// @public (undocumented)
export type ThemeControlsClassName<T extends KebabCase<string> = KebabCase<string>> = `theme-${T}-controls`;

// @public (undocumented)
export function toKebabCase(value: string): string;

// @public
export function trimString(value: string, characters: string): string;

// @public (undocumented)
export type Try<A1, A2, Catch = never> = A1 extends A2 ? A1 : Catch;

// @public (undocumented)
export type TypeofStringLiteral<T> = string extends T ? never : T;

// @public (undocumented)
export type UnionOfPredicateTypes<T> = T extends Array<(value: any) => value is infer U> ? U : never;

export { UnionToIntersection }

export { UnwrapOpaque }

// (No @packageDocumentation comment for this package)

```
